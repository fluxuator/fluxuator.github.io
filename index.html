<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>shkodiak.com</title>
    <meta name="description" content="Landing"/>
    <style>
        :root {
            --bg: #070A12;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 800px at 20% 20%, #121a3a 0%, var(--bg) 55%, #05060b 100%);
            overflow: hidden;
        }

        #bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* subtle grain / haze */
        .grain {
            pointer-events: none;
            position: fixed;
            inset: 0;
            background-image: radial-gradient(circle at 20% 18%, rgba(170, 190, 255, 0.10), transparent 58%),
            radial-gradient(circle at 72% 82%, rgba(170, 255, 230, 0.08), transparent 60%),
            url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
            opacity: 0.55;
        }
    </style>
</head>

<body>
<canvas id="bg" aria-hidden="true"></canvas>
<div class="grain" aria-hidden="true"></div>

<script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const canvas = document.getElementById("bg");

    // Renderer
    const renderer = new THREE.WebGLRenderer({canvas, antialias: true, alpha: true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);

    // Scene & camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a12, 0.055);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 140);
    camera.position.set(0, 0, 20);

    // Soft, pastel lighting (no “specular” vibe)
    const key = new THREE.DirectionalLight(0xe9eeff, 0.85);
    key.position.set(7, 10, 10);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xd8fff0, 0.55);
    fill.position.set(-10, -6, 7);
    scene.add(fill);

    scene.add(new THREE.AmbientLight(0xcfd6ff, 0.35));

    // Fake background glow plane (very subtle)
    const glow = new THREE.Mesh(
        new THREE.PlaneGeometry(90, 90),
        new THREE.MeshBasicMaterial({color: 0x3a4aa8, transparent: true, opacity: 0.06, depthWrite: false})
    );
    glow.position.set(0, 0, -28);
    scene.add(glow);

    // Matte pastel materials (low metalness, high roughness)
    const matte = (color, opacity = 0.92) =>
        new THREE.MeshStandardMaterial({
            color,
            metalness: 0.0,
            roughness: 0.92,
            transparent: true,
            opacity,
            emissive: new THREE.Color(color).multiplyScalar(0.06),
            emissiveIntensity: 1.0,
        });

    const palette = [
        matte(0xbcc7ff, 0.92), // pastel blue
        matte(0xcff9ee, 0.88), // mint
        matte(0xf6c7df, 0.86), // pastel pink
        matte(0xd9ccff, 0.90), // lavender
        matte(0xfff1c6, 0.78), // soft warm accent
    ];

    // Geometries
    const geos = [
        new THREE.IcosahedronGeometry(1.25, 0),
        new THREE.DodecahedronGeometry(1.15, 0),
        new THREE.OctahedronGeometry(1.05, 0),
        new THREE.TetrahedronGeometry(1.05, 0),
        new THREE.TorusGeometry(1.05, 0.22, 18, 64),
        new THREE.TorusKnotGeometry(0.85, 0.28, 120, 16),
    ];

    // Stars (pastel dust)
    const dustCount = 950;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
        dustPos[i * 3 + 0] = (Math.random() - 0.5) * 140;
        dustPos[i * 3 + 1] = (Math.random() - 0.5) * 90;
        dustPos[i * 3 + 2] = -Math.random() * 90;
    }
    dustGeo.setAttribute("position", new THREE.BufferAttribute(dustPos, 3));
    const dust = new THREE.Points(
        dustGeo,
        new THREE.PointsMaterial({size: 0.035, transparent: true, opacity: 0.45})
    );
    scene.add(dust);

    // Floating objects with “physics-ish” cursor reaction
    const objects = [];
    const COUNT = 22;

    const rand = (a, b) => a + Math.random() * (b - a);

    for (let i = 0; i < COUNT; i++) {
        const geo = geos[(Math.random() * geos.length) | 0];
        const mat = palette[(Math.random() * palette.length) | 0];
        const mesh = new THREE.Mesh(geo, mat);

        mesh.position.set(rand(-11, 11), rand(-8, 8), rand(-12, 12));
        mesh.rotation.set(rand(0, Math.PI), rand(0, Math.PI), rand(0, Math.PI));
        mesh.scale.setScalar(rand(0.7, 1.45));

        mesh.userData.vel = new THREE.Vector3(rand(-0.02, 0.02), rand(-0.018, 0.018), rand(-0.016, 0.016));
        mesh.userData.baseVel = mesh.userData.vel.clone();
        mesh.userData.rot = new THREE.Vector3(rand(-0.010, 0.010), rand(-0.012, 0.012), rand(-0.010, 0.010));
        mesh.userData.phase = rand(0, Math.PI * 2);
        mesh.userData.wobble = rand(0.6, 1.7);

        objects.push(mesh);
        scene.add(mesh);
    }

    // Pointer -> world point on z=0 plane
    const pointer = new THREE.Vector2(0, 0);
    let pointerActive = false;

    window.addEventListener(
        "pointermove",
        (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            pointerActive = true;
        },
        {passive: true}
    );

    window.addEventListener(
        "pointerleave",
        () => {
            pointerActive = false;
        },
        {passive: true}
    );

    function pointerWorldPointZ0() {
        // project pointer ray to plane z=0
        const v = new THREE.Vector3(pointer.x, pointer.y, 0.5).unproject(camera);
        const dir = v.sub(camera.position).normalize();
        const t = (0 - camera.position.z) / dir.z;
        return camera.position.clone().add(dir.multiplyScalar(t));
    }

    // Resize
    function onResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }

    window.addEventListener("resize", onResize);

    // Animation
    const clock = new THREE.Clock();

    function tick() {
        const t = clock.getElapsedTime();
        const dt = Math.min(clock.getDelta(), 0.033);

        // very subtle camera parallax
        if (pointerActive) {
            camera.position.x += (pointer.x * 1.2 - camera.position.x) * 0.025;
            camera.position.y += (pointer.y * 0.9 - camera.position.y) * 0.025;
        } else {
            camera.position.x += (0 - camera.position.x) * 0.02;
            camera.position.y += (0 - camera.position.y) * 0.02;
        }
        camera.lookAt(0, 0, 0);

        dust.rotation.y = t * 0.018;
        dust.rotation.x = t * 0.010;

        const bounds = {x: 13, y: 9.5, z: 13};

        // cursor influence
        const pWorld = pointerActive ? pointerWorldPointZ0() : null;
        const influenceRadius = 6.2;     // how far cursor affects
        const repelStrength = 1.25;      // increase for stronger push
        const springToDrift = 0.12;      // how much they return to their baseline drift
        const damping = 0.965;           // “air resistance”

        for (const m of objects) {
            const vel = m.userData.vel;

            // baseline drift gently pulls velocity back to baseVel
            vel.lerp(m.userData.baseVel, springToDrift * dt);

            // cursor repulsion in world space
            if (pWorld) {
                const toObj = m.position.clone().sub(pWorld);
                const dist = toObj.length();

                if (dist < influenceRadius) {
                    // smooth falloff (strong near cursor, soft farther away)
                    const k = (1 - dist / influenceRadius);
                    const force = toObj.normalize().multiplyScalar(repelStrength * k * k * dt);
                    vel.add(force);
                }
            }

            // wobble
            m.position.y += Math.sin(t * m.userData.wobble + m.userData.phase) * 0.002;

            // integrate
            m.position.add(vel);

            // rotate
            m.rotation.x += m.userData.rot.x;
            m.rotation.y += m.userData.rot.y;
            m.rotation.z += m.userData.rot.z;

            // damping
            vel.multiplyScalar(damping);

            // wrap
            if (m.position.x > bounds.x) m.position.x = -bounds.x;
            if (m.position.x < -bounds.x) m.position.x = bounds.x;
            if (m.position.y > bounds.y) m.position.y = -bounds.y;
            if (m.position.y < -bounds.y) m.position.y = bounds.y;
            if (m.position.z > bounds.z) m.position.z = -bounds.z;
            if (m.position.z < -bounds.z) m.position.z = bounds.z;
        }

        renderer.render(scene, camera);
        requestAnimationFrame(tick);
    }

    tick();
</script>
</body>
</html>
